# TCP回射程序

该程序实现的功能是在客户端进行输入后，服务端返回相同的内容，客户端与服务端之间通过TCP协议进行通信。

运行方法：
```
# 服务端后台运行
./server & 

#运行客户端连接服务端
./client 127.0.0.1

>>> hello
<<< hello

#结束程序
ctrl+D 终止程序
```
在服务端，程序依次调用`Socket`、`Bind`、`Listen`、`Accept`函数来创建、绑定socket，并将其绑定至相应的端口，整个程序阻塞于`Accept`调用，等待连接的建立。

在客户端，程序依次调用`Socket`、`Connect`函数创建socket并建立到服务端的连接。

在连接建立后，使用`netstat -a`命令查看设备上`./server`程序的运行情况，该程序占用9877端口(由SERV_PORT指定)，在连接建立后服务端程序中`Accept`函数创建的新socket同样使用9877端口。


在程序终止时：
1. 输入`ctrl+D`，内容回显函数退出，客户端程序调用`exit`函数退出，退出后会关闭所有打开的描述符，包括socket描述符，这样就使得内核向服务端发送一个FIN分节并等待服务端的ACK，开始断开连接的过程，在收到服务端的ACK之后，客户端进入`FIN_WAIT_2`状态，服务端进入`CLOSE_WAIT`状态。
2. 服务端在接收到FIN分节后，回显处理函数退出，调用`exit`函数退出当前子进程，因此内核关闭该子进程中的所有描述符(将socket的引用计数减一)，并向客户端发送FIN分节，等待客户端的ACK。在客户端发送、服务端接收ACK之后，客户端socket进入`TIME_WAIT`状态，服务端的连接已经被动关闭。
3. 同时在子进程终止时，子进程会向父进程发送一个`SIGCHLD`信号，在本例程序中，父进程并未处理该信号，因此会导致子进程进入僵死状态。
   
   使用`ps`命令加`stat`参数可查看进程的状态

## 信号处理

1. 什么是信号？
   
   信号是告知某个进程发生了某个事件的通知，通常是<font color=#FF00>异步</font>发生的，信号通常是由一个进程发给一个进程(可以是自身)，也可以由内核发给进程。信号通常都有自己的标识(一般为整型数字)

2. 如何进行信号处理？
   
   有三种方式来对信号进行处理方法：
   
   1. 调用处理函数：当有特定信号发生时，该函数就会被调用。`SIGKILL`与`SIGSTOP`两种信号不能被捕获。
   2. 忽略信号：将某个信号的处置设定为`SIG_IGN`来忽略该信号，`SIGKILL`与`SIGSTOP`两种信号不能被忽略。
   3. 默认处理：将某个信号的处置设定为`SIG_DFL`来启用默认的处置程序，一般的默认处置方法是在收到信号后终止进程。

   如果需要建立对信号处理的方法，那就得调用`signaction`函数，更为简便一点的是调用`signal`函数，`signal`函数是在`signaction`外做了一层包裹。该函数的原型如下：
   ```c
   void (*signal(int signo, void (*func)(int))) (int)
   ```
   首先该函数返回一个函数指针，该函数指针指向一个参数为`int`型(由最后小括号内的int确定)的函数

   被指向的函数就是
   ```c
   signal(int signo, void (*func)(int) )
   ```
   `signal`函数的参数一个为`int`型，标识信号类型，一个为函数指针，指向信号的处理函数，该处理函数仅有一个整型参数，并且返回值为空。

   <font color=#FF000>`signal`函数的返回值、第二个参数都是指向信号处理函数的指针</font>

   在`signal`函数调用时，除了被捕获的信号，其余的信号都没有被阻塞，并且每个信号最多只会被提交一次。这个特性也会导致漏处理一些信号：
   
    如在程序`tcpReflectionServerSign.c`与`tcpReflectionClientFive.c`中建立五个并行连接，但是当终止客户端程序时，服务端会有五个子进程向父进程发送`SIGCHLD`信号，但是服务端只会处部分僵死进程(实验时处理了两个)，依赖于FIN到达服务端的时机。<font color=#FF00>只处理了部分僵死进程这是由于信号处理函数中调用`wait`，正确的方法应该是调用`waitpid`，并借助循环来实现处理所有的僵死进程</font>




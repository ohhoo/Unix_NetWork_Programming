# TCP回射程序

该程序实现的功能是在客户端进行输入后，服务端返回相同的内容，客户端与服务端之间通过TCP协议进行通信。

运行方法：
```
# 服务端后台运行
./server & 

#运行客户端连接服务端
./client 127.0.0.1

>>> hello
<<< hello

#结束程序
ctrl+D 终止程序
```
在服务端，程序依次调用`Socket`、`Bind`、`Listen`、`Accept`函数来创建、绑定socket，并将其绑定至相应的端口，整个程序阻塞于`Accept`调用，等待连接的建立。

在客户端，程序依次调用`Socket`、`Connect`函数创建socket并建立到服务端的连接。

在连接建立后，使用`netstat -a`命令查看设备上`./server`程序的运行情况，该程序占用9877端口(由SERV_PORT指定)，在连接建立后服务端程序中`Accept`函数创建的新socket同样使用9877端口。


在程序终止时：
1. 输入`ctrl+D`，内容回显函数退出，客户端程序调用`exit`函数退出，退出后会关闭所有打开的描述符，包括socket描述符，这样就使得内核向服务端发送一个FIN分节并等待服务端的ACK，开始断开连接的过程，在收到服务端的ACK之后，客户端进入`FIN_WAIT_2`状态，服务端进入`CLOSE_WAIT`状态。
2. 服务端在接收到FIN分节后，回显处理函数退出，调用`exit`函数退出当前子进程，因此内核关闭该子进程中的所有描述符(将socket的引用计数减一)，并向客户端发送FIN分节，等待客户端的ACK。在客户端发送、服务端接收ACK之后，客户端socket进入`TIME_WAIT`状态，服务端的连接已经被动关闭。
3. 同时在子进程终止时，子进程会向父进程发送一个`SIGCHLD`信号，在本例程序中，父进程并未处理该信号，因此会导致子进程进入僵死状态。
   
   使用`ps`命令加`stat`参数可查看进程的状态

## 信号处理

1. 什么是信号？
   
   信号是告知某个进程发生了某个事件的通知，通常是<font color=#FF00>异步</font>发生的，信号通常是由一个进程发给一个进程(可以是自身)，也可以由内核发给进程。信号通常都有自己的标识(一般为整型数字)

2. 如何进行信号处理？
   
   有三种方式来对信号进行处理方法：
   
   1. 调用处理函数：当有特定信号发生时，该函数就会被调用。`SIGKILL`与`SIGSTOP`两种信号不能被捕获。
   2. 忽略信号：将某个信号的处置设定为`SIG_IGN`来忽略该信号，`SIGKILL`与`SIGSTOP`两种信号不能被忽略。
   3. 默认处理：将某个信号的处置设定为`SIG_DFL`来启用默认的处置程序，一般的默认处置方法是在收到信号后终止进程。

   如果需要建立对信号处理的方法，那就得调用`signaction`函数，更为简便一点的是调用`signal`函数，`signal`函数是在`signaction`外做了一层包裹。该函数的原型如下：
   ```c
   void (*signal(int signo, void (*func)(int))) (int)
   ```
   首先该函数返回一个函数指针，该函数指针指向一个参数为`int`型(由最后小括号内的int确定)的函数

   被指向的函数就是
   ```c
   signal(int signo, void (*func)(int) )
   ```
   `signal`函数的参数一个为`int`型，标识信号类型，一个为函数指针，指向信号的处理函数，该处理函数仅有一个整型参数，并且返回值为空。

   <font color=#FF000>`signal`函数的返回值、第二个参数都是指向信号处理函数的指针</font>

   在`signal`函数调用时，除了被捕获的信号，其余的信号都没有被阻塞，并且每个信号最多只会被提交一次。这个特性也会导致漏处理一些信号：
   
    如在程序`tcpReflectionServerSign.c`与`tcpReflectionClientFive.c`中建立五个并行连接，但是当终止客户端程序时，服务端会有五个子进程向父进程发送`SIGCHLD`信号，但是服务端只会处部分僵死进程(实验时处理了两个)，依赖于FIN到达服务端的时机。<font color=#FF00>只处理了部分僵死进程这是由于信号处理函数中调用`wait`，正确的方法应该是调用`waitpid`，并借助循环来实现处理所有的僵死进程</font>


## 在TCP回显程序运行时可能遇到的问题
1. 当客户端在服务端调用`Accept`函数返回前断开连接，服务端将会如何响应？

    问题复现：当三次握手已经完成，TCP连接建立连接已经由TCP加入排队序列等待accept调用，此时客户端发送RST分节

    这种连接终止情况会在部分的实现中会由内核中进行处理，但大部分的处理方法是返回一个错误，标明这是由客户引起的非致命的连接终止情况，同时再重新调用`accept`函数即可。

2. 当服务端的子进程终止时，客户端会如何处理？
    
    问题复现：在客户端与服务端的连接建立后，关闭服务端的相应子进程。

    在服务端关闭了相应进程后，客户端并没有收到显示的通知，只有当再次键入文本并发送时才会由于服务端进程已关闭而出错并退出，出错信息为`server terminated prematurely`

    在服务端关闭子进程后所有的描述符都被关闭，因此服务端会向客户端发送FIN分节断开连接，此时的客户端发送ACK响应服务端的FIN分节，但是此时的问题是客户端进程阻塞于`fgets`调用上，等待从终端键入的文本，此时如果键入了文本是可以向服务端发送的，但是服务端并不会接收而是返回一个RST，同时由于客户端在写入后会进入`readline`进行读取，但是由于之前服务端发送的FIN分节，调用的`readline`会返回0(EOF),因此会以错误信息退出。

    <font color=#FF00>问题在于客户端单纯地阻塞于`fgets`调用上，导致没有及时地对FIN分节进行反应</font>


3. 如果客户端不理会`readline`函数返回的错误，反而向服务端写入更多的数据时，将会发生什么？

    错误复现：在客户端读取数据之前执行两次写操作，并且其中的第一次写操作会引发RST。

    当一个进程向已经收到RST的socket继续执行写操作时，内核会向该进程发送`SIGPIPE`信号，该信号的默认操作是终止进程，因此必须对该信号进行处理，但是不论是处理还是忽略该信号，写操作都将返回`EPIPE`错误，因此需要对`EPIPE`类型的错误进行处理。

4. 服务器主机崩溃时会发生什么？

    在服务器主机崩溃后，已有的网络连接上服务端是无法发出任何信息的。

    崩溃后的服务器既无法给出正确的回复，也无法发出RST，更无法主动断开连接。因此我们能够观测到的现象就是客户端持续地重传数据分节，直至超时时间到达。

    当无法接受过长的超时时间时，应当主动对`readline`调用设置一个超时时间。
   
5. 服务器主机崩溃重启时会发生什么？

    当服务器崩溃后重启，这将会丢失崩溃前的TCP连接信息。

    因此，当客户端的数据到达时，服务端会响应RST。

6. 服务器关闭时会发生什么？

    当服务器主动关机时，首先服务器的进程会被`SIGKILL`信号终止，所有打开的连接符都会被关闭。后续的现象就等同于服务器进程被终止后发生的现象。


当我们在客户端与服务端之间传递字符串时，回显程序在文本处理上不会出现问题，但是当我们传递二进制数据时就要受到不同主机上字节序的影响。
